<#
.SYNOPSIS
    Retrieves and evaluates the Configuration Manager (CCM) client health status on one or more remote computers.

.DESCRIPTION
    The `Get-CCMClientHealth` function connects to specified remote computers, retrieves the health status of the Configuration Manager client,
    and outputs a summary of the health check. This function requires the computer name(s) and credentials for access.

    This function performs the following:
    - Establishes a CIM session on each specified computer to retrieve client information.
    - Executes a client health evaluation using the `ccmeval.exe` utility on the remote machine.
    - Reads and parses the `CcmEvalReport.xml` file to gather detailed health check information.

.PARAMETER ComputerName
    Specifies the name(s) of the computer(s) on which to check the CCM client health. This parameter is mandatory.

.PARAMETER Credential
    Specifies a user credential with administrative access to the target computers. This parameter is mandatory.

.OUTPUTS
    Custom output generated by the `CCMEval` class, providing information on the client status, health check summary, and detailed health check results.

.EXAMPLE
    PS C:\> Get-CCMClientHealth -ComputerName "Computer1", "Computer2" -Credential (Get-Credential)

    Retrieves the Configuration Manager client health status for "Computer1" and "Computer2" using the specified credentials.

.NOTES
    Author: Jonathon Sissom
    Date: 11/06/2024
    Version: 1.01

    This function uses CIM sessions and remote commands to gather client health data from remote systems. 
    Ensure that the `SMS_Client` class is available on the remote computer.

#>
function Get-CCMClientHealth {
    [CmdletBinding()]
    param (
        # Parameter help description
        [Parameter(Mandatory)]
        [string[]]
        $ComputerName,
        # Parameter help description
        [Parameter(Mandatory)]
        [pscredential]
        $Credential
    )
    
    begin {
            class CCMEval {
                [Client]$Client
                [HealthCheckSummary]$Summary
                [HealthCheckResult[]]$HealthChecks
            
                # Constructor for CCMEval
                CCMEval([CimInstance]$smsClient, [object]$healthCheckSummary, [System.Xml.XmlElement[]]$healthChecks) {
                    # Initialize Client object
                    $this.Client = [Client]::new($smsClient)
            
                    # Initialize HealthCheckSummary object
                    $this.Summary = [HealthCheckSummary]::new($healthCheckSummary)
            
                    # Initialize HealthChecks array with HealthCheckResult objects
                    $this.HealthChecks = $healthChecks | ForEach-Object { [HealthCheckResult]::new($_) }
                }

                # Returns a structured custom object for detailed information
                [PSCustomObject] ToStructuredOutput() {
                    return [pscustomobject]@{
                        ClientInfo = [pscustomobject]@{
                            ComputerName = $this.Client.ComputerName
                            Version = $this.Client.Version
                            Type = $this.Client.Type
                            AllowLocalAdminOverride = $this.Client.AllowLocalAdminOveride
                            EnableAutoAssignment = $this.Client.EnableAutoAssignment
                        }
                        HealthCheckSummary = [pscustomobject]@{
                            EvaluationDate = $this.Summary.EvaluationDate
                            Version = $this.Summary.Version
                            Result = $this.Summary.Result
                        }
                        HealthChecks = $this.HealthChecks | ForEach-Object {
                            [pscustomobject]@{
                                ID = $_.ID
                                Description = $_.Description
                                ResultCode = $_.ResultCode
                                ResultType = $_.ResultType
                                ResultDetail = $_.ResultDetail
                                StepDetail = $_.StepDetail
                                ResultStatus = $_.ResultStatus
                            }
                        }
                    }
                }

                # Returns a JSON representation for easy integration with other tools
                [string] ToJson() {
                    return (ConvertTo-Json -InputObject $this.ToStructuredOutput() -Depth 10)
                }

                # Returns a brief summary of health check status
                [pscustomobject] GetSummary() {
                    return [PSCustomObject]@{
                        ComputerName = $this.Client.ComputerName
                        ClientVersion = $this.Client.Version.ToString()
                        EvaluationDate = $this.Summary.EvaluationDate
                        Version = $this.Summary.Version.ToString()
                        Result = $this.Summary.Result
                    }
                }

                # ToString method to format output
                [string] ToString() {
                    $output = @()
                    $output += "Client Info:"
                    $output += "--------------------------"
                    $output += "Computer Name: $($this.Client.ComputerName)"
                    $output += "Client Version: $($this.Client.Version)"
                    $output += "Client Type: $($this.Client.Type)"
                    $output += "Allow Local Admin Override: $($this.Client.AllowLocalAdminOveride)"
                    $output += ""
                    $output += "Health Check Summary:"
                    $output += "--------------------------"
                    $output += "Evaluation Date: $($this.Summary.EvaluationDate)"
                    $output += "Summary Result: $($this.Summary.Result)"
                    $output += "Summary Version: $($this.Summary.Version)"

                    return $output -join "`n"
                }
            }
            class Client {
                [bool]$AllowLocalAdminOveride
                [int]$Type
                [version]$Version
                [bool]$EnableAutoAssignment
                [string]$ComputerName

                Client([CimInstance]$smsClient){
                    $this.AllowLocalAdminOveride = $smsClient.AllowLocalAdminOverride
                    $this.Type = $smsClient.ClientType
                    $this.Version = $smsClient.ClientVersion
                    $this.EnableAutoAssignment = $smsClient.EnableAutoAssignment
                    $this.ComputerName = $smsClient.PSComputerName
                }
            }
            class HealthCheckSummary {
                [datetime]$EvaluationDate
                [version]$Version
                [string]$Result

                HealthCheckSummary([object[]]$healthCheckSummary){
                    $this.EvaluationDate = $healthCheckSummary.EvaluationTime
                    $this.Version = $healthCheckSummary.Version
                    $this.Result = $healthCheckSummary.'#text'
                }
            }
            class HealthCheckResult {
                [string]$ID
                [string]$Description
                [int]$ResultCode
                [int]$ResultType
                [string]$ResultDetail
                [string]$StepDetail
                [string]$ResultStatus

                HealthCheckResult([System.Xml.XmlElement]$healthCheck) {
                    # Extract values from the XML element
                    $this.ID = $healthCheck.ID
                    $this.Description = $healthCheck.Description
                    $this.ResultCode = [int]$healthCheck.ResultCode
                    $this.ResultType = [int]$healthCheck.ResultType
                    $this.ResultDetail = $healthCheck.ResultDetail
                    $this.StepDetail = $healthCheck.StepDetail
                    # Map '#text' to ResultStatus
                    $this.ResultStatus = $healthCheck.'#text'
                }
            }
    }
    
    process {
        # Define a thread-safe collection to store results from parallel executions
        $results = [System.Collections.Concurrent.ConcurrentBag[object]]::new()
        $argList = @($Credential, $results)
        # Run each computer check in parallel
        $ComputerName | ForEach-Object -Parallel {

            try {
                Write-Output $_
                # Establish a CIM session
                $cimSession = New-CimSession -ComputerName $_ -Credential $using:Credential -ErrorAction Stop

                Write-Output $cimSession

                # Retrieve the SMS client
                $smsClient = Get-CimInstance -Namespace "root/ccm" -ClassName SMS_Client -CimSession $cimSession
                if (-not $smsClient) {
                    Write-Warning "SMS_Client class not found on $_"
                    return
                }

                Write-Output $smsClient

                # Get local SMS path and check for required files
                $localSMSPath = (Invoke-Command -ComputerName $_ -Credential $using:Credential -ScriptBlock {
                    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Client\Configuration\Client Properties"
                })."Local SMS Path"

                Write-Output $localSMSPath

                $ccmEvalPath = "${localSMSPath}ccmeval.exe"
                $ccmEvalReportPath = "${localSMSPath}CcmEvalReport.xml"
                Write-Output $ccmEvalPath
                Write-Output $ccmEvalReportPath
                if (!(Test-Path -Path $ccmEvalPath)) {
                    Write-Warning "ccmeval.exe not found on $_"
                    return
                }

                # Execute CCM evaluation remotely
                Invoke-Command -ComputerName $_ -Credential $using:Credential -ScriptBlock {
                    $localSMSPath = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Client\Configuration\Client Properties")."Local SMS Path"
                    $ccmEvalPath = "${localSMSPath}ccmeval.exe"
                    Write-Output $ccmEvalPath
                    Start-Process -FilePath $ccmEvalPath -NoNewWindow -Wait
                } -ErrorAction Stop

                # Check for the report file
                if (!(Test-Path -Path $ccmEvalReportPath)) {
                    Write-Warning "CcmEvalReport.xml not found on $_ after evaluation"
                    return
                }

                # Retrieve and parse the XML report
                [xml]$ccmEvalReport = Invoke-Command -ComputerName $_ -Credential $using:Credential -ScriptBlock {
                    $localSMSPath = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Client\Configuration\Client Properties")."Local SMS Path"
                    $ccmEvalReportPath = "${localSMSPath}CcmEvalReport.xml"
                    Get-Content -Path $ccmEvalReportPath
                } -ErrorAction Stop

                [object[]]$ccmHealthChecks = $ccmEvalReport.ClientHealthReport.HealthChecks.HealthCheck
                [object[]]$ccmHealthCheckSummary = $ccmEvalReport.ClientHealthReport.Summary

                # Create CCMEval instance and add it to results
                $ccmEval = [CCMEval]::new($smsClient, $ccmHealthCheckSummary, $ccmHealthChecks)
                $results.Add($ccmEval)  # Add result to the concurrent bag
            }
            catch {
                Write-Error "Failed to retrieve client health status for $_ : $_"
            }
            finally {
                # Clean up CIM session
                if ($cimSession) {
                    $cimSession | Remove-CimSession
                }
            }

        }-ArgumentList $argList -ThrottleLimit 5  
    }
    
    end {
        $results.ToArray() | ForEach-Object {
            $_.GetSummary()
            if ($_.Summary.Result -ne "Passed"){
                $_.HealthChecks | Foreach-Object {
                    if ($_.ResultCode -ne 0){
                        Write-Output $_
                    }
                } 
            }
        }

        if ($PSCmdlet.MyInvocation.BoundParameters["OutVariable"]) {
            $OutVariableName = $PSCmdlet.MyInvocation.BoundParameters["OutVariable"]
            Set-Variable -Name $OutVariableName -Value $results.ToArray() -Scope 1 -Option AllScope
        }
    }
}